"""
Business Conversation Simulator v2.0
Interaktywny symulator rozm√≥w biznesowych z:
- Wyborem poziomu trudno≈õci
- AI-generowanym kontekstem
- Mo≈ºliwo≈õciƒÖ poprawiania odpowiedzi
"""

import streamlit as st
from typing import Dict, Optional, List
import json
import re

# ===============================================
# SCENARIUSZE ROZM√ìW - BAZOWE SZABLONY
# ===============================================

SCENARIOS = {
    "salary_raise": {
        "name": "üí∞ Rozmowa o podwy≈ºkƒô",
        "description": "Prosisz szefa o podwy≈ºkƒô",
        "ai_role": "Szef",
        "user_role": "Pracownik",
        "initiator": "user",
        "category": "wynagrodzenia",
        "optimal_ciq": {
            "opening": [2, 3],  # Pozycyjny (argumenty) lub Transformacyjny (wizja rozwoju)
            "middle": [3],  # Transformacyjny (budowanie warto≈õci)
            "crisis": [1, 2],  # Transakcyjny (konkretne liczby) lub Pozycyjny (uzasadnienie)
            "closing": [3]  # Transformacyjny (d≈Çugoterminowa wsp√≥≈Çpraca)
        },
        "context_notes": "C-IQ I akceptowalny przy przedstawianiu konkretnych oczekiwa≈Ñ finansowych. C-IQ II dobry przy argumentacji osiƒÖgniƒôciami. C-IQ III optymalny przy budowaniu wizji wsp√≥lnego rozwoju."
    },
    "difficult_feedback": {
        "name": "üì¢ Trudny feedback",
        "description": "Przekazujesz trudny feedback pracownikowi",
        "ai_role": "Pracownik",
        "user_role": "Mened≈ºer",
        "initiator": "user",
        "category": "zarzƒÖdzanie",
        "optimal_ciq": {
            "opening": [2, 3],  # Pozycyjny (jasne standardy) lub Transformacyjny (rozw√≥j)
            "middle": [3],  # Transformacyjny (wsparcie i rozw√≥j)
            "crisis": [2],  # Pozycyjny (jasne granice)
            "closing": [3]  # Transformacyjny (plan rozwoju)
        },
        "context_notes": "C-IQ II optymalny przy okre≈õlaniu granic i standard√≥w. C-IQ III najlepszy przy budowaniu planu naprawczego i wspieraniu rozwoju."
    },
    "team_conflict": {
        "name": "‚ö° Konflikt w zespole",
        "description": "RozwiƒÖzujesz konflikt miƒôdzy cz≈Çonkami zespo≈Çu",
        "ai_role": "Cz≈Çonek zespo≈Çu",
        "user_role": "Mediator",
        "initiator": "user",
        "category": "konflikty",
        "optimal_ciq": {
            "opening": [2, 3],  # Pozycyjny (zasady) lub Transformacyjny (mediacja)
            "middle": [3],  # Transformacyjny (zrozumienie perspektyw)
            "crisis": [2],  # Pozycyjny (przywr√≥cenie porzƒÖdku)
            "closing": [3]  # Transformacyjny (budowanie wsp√≥lnej wizji)
        },
        "context_notes": "C-IQ II skuteczny przy ustalaniu zasad dyskusji. C-IQ III kluczowy przy budowaniu porozumienia i wsp√≥lnych rozwiƒÖza≈Ñ."
    },
    "delegation": {
        "name": "üìã Delegowanie zadania",
        "description": "Delegujesz zadanie przeciƒÖ≈ºonemu pracownikowi",
        "ai_role": "Pracownik",
        "user_role": "Mened≈ºer",
        "initiator": "user",
        "category": "zarzƒÖdzanie",
        "optimal_ciq": {
            "opening": [1, 2],  # Transakcyjny (pilne) lub Pozycyjny (wyja≈õnienie)
            "middle": [3],  # Transformacyjny (zrozumienie sytuacji)
            "crisis": [1],  # Transakcyjny (szybka decyzja)
            "closing": [3]  # Transformacyjny (wsparcie)
        },
        "context_notes": "C-IQ I optymalny w sytuacjach pilnych - jasne, szybkie komunikaty. C-IQ II dobry przy wyja≈õnianiu priorytet√≥w. C-IQ III najlepszy przy wsp√≥lnym szukaniu rozwiƒÖza≈Ñ."
    },
    "motivation": {
        "name": "üî• Motywowanie pracownika",
        "description": "Motywujesz zdemotywowanego pracownika",
        "ai_role": "Pracownik",
        "user_role": "Mened≈ºer",
        "initiator": "user",
        "category": "motywacja",
        "optimal_ciq": {
            "opening": [3],  # Transformacyjny (empatia)
            "middle": [3],  # Transformacyjny (zrozumienie przyczyn)
            "crisis": [2],  # Pozycyjny (przypomnienie cel√≥w)
            "closing": [3]  # Transformacyjny (plan dzia≈Çania)
        },
        "context_notes": "C-IQ III dominuje - motywacja wymaga g≈Çƒôbokiego zrozumienia i budowania zaanga≈ºowania. C-IQ II pomocny przy przypominaniu o celach i standardach."
    },
    "change_resistance": {
        "name": "üîÑ Op√≥r wobec zmian",
        "description": "Przekonujesz zesp√≥≈Ç do zmian organizacyjnych",
        "ai_role": "Cz≈Çonek zespo≈Çu",
        "user_role": "Lider zmiany",
        "initiator": "user",
        "category": "zmiany",
        "optimal_ciq": {
            "opening": [2, 3],  # Pozycyjny (powody zmian) lub Transformacyjny (wizja)
            "middle": [3],  # Transformacyjny (adresowanie obaw)
            "crisis": [2],  # Pozycyjny (konieczno≈õƒá zmian)
            "closing": [3]  # Transformacyjny (wsp√≥lna realizacja)
        },
        "context_notes": "C-IQ II skuteczny przy wyja≈õnianiu biznesowej konieczno≈õci zmian. C-IQ III kluczowy przy budowaniu zaanga≈ºowania i wsp√≥≈Çtworzeniu rozwiƒÖza≈Ñ."
    },
    "difficult_client": {
        "name": "üò§ Trudny klient",
        "description": "Uspokajasz niezadowolonego klienta",
        "ai_role": "Klient",
        "user_role": "Account Manager",
        "initiator": "ai",
        "category": "klienci",
        "optimal_ciq": {
            "opening": [1],  # Transakcyjny (natychmiastowa reakcja)
            "middle": [2, 3],  # Pozycyjny (procedury) lub Transformacyjny (odbudowa relacji)
            "crisis": [1],  # Transakcyjny (szybkie dzia≈Çanie)
            "closing": [3]  # Transformacyjny (d≈Çugoterminowa relacja)
        },
        "context_notes": "C-IQ I optymalny na starcie - klient potrzebuje szybkiej, konkretnej reakcji. C-IQ II dobry przy wyja≈õnianiu procedur. C-IQ III najlepszy przy odbudowie zaufania."
    },
    "negotiation": {
        "name": "üíº Negocjacje",
        "description": "Negocjujesz warunki wsp√≥≈Çpracy",
        "ai_role": "Partner biznesowy",
        "user_role": "Negocjator",
        "initiator": "user",
        "category": "negocjacje",
        "optimal_ciq": {
            "opening": [2, 3],  # Pozycyjny (pozycja) lub Transformacyjny (partnerstwo)
            "middle": [2, 3],  # Mix - zale≈ºnie od stylu negocjacji
            "crisis": [2],  # Pozycyjny (stanowczo≈õƒá)
            "closing": [3]  # Transformacyjny (win-win)
        },
        "context_notes": "C-IQ I akceptowalny przy wymianie konkret√≥w. C-IQ II skuteczny przy obronie swojej pozycji. C-IQ III optymalny przy budowaniu partnerstwa win-win."
    }
}

DIFFICULTY_LEVELS = {
    "easy": {
        "name": "üü¢ ≈Åatwy",
        "description": "Rozm√≥wca jest otwarty na dialog, ≈Çagodny, chƒôtny do wsp√≥≈Çpracy",
        "ai_behavior": "BƒÖd≈∫ bardzo otwarty, przyja≈∫nie nastawiony, ≈Çatwo przychodzi Ci kompromis i zrozumienie"
    },
    "medium": {
        "name": "üü° ≈öredni",
        "description": "Rozm√≥wca jest sceptyczny, ale mo≈ºliwy do przekonania",
        "ai_behavior": "BƒÖd≈∫ umiarkowanie sceptyczny, wymagaj dobrej argumentacji, ale bƒÖd≈∫ otwarty na dobrze przedstawione argumenty"
    },
    "hard": {
        "name": "üî¥ Trudny",
        "description": "Rozm√≥wca jest defensywny, niechƒôtny, wymaga najwy≈ºszych umiejƒôtno≈õci",
        "ai_behavior": "BƒÖd≈∫ bardzo defensywny, wymagajƒÖcy, sceptyczny. Tylko najwy≈ºszy poziom C-IQ (Transformacyjny) i perfekcyjna argumentacja mogƒÖ Ciƒô przekonaƒá"
    }
}

# ===============================================
# INICJALIZACJA SESSION STATE
# ===============================================

def init_simulator_state():
    """Inicjalizuje stan symulatora"""
    if 'sim_scenario' not in st.session_state:
        st.session_state.sim_scenario = None
    if 'sim_difficulty' not in st.session_state:
        st.session_state.sim_difficulty = None
    if 'sim_context' not in st.session_state:
        st.session_state.sim_context = None
    if 'sim_ai_persona' not in st.session_state:
        st.session_state.sim_ai_persona = None
    if 'sim_messages' not in st.session_state:
        st.session_state.sim_messages = []
    if 'sim_started' not in st.session_state:
        st.session_state.sim_started = False
    if 'sim_context_generated' not in st.session_state:
        st.session_state.sim_context_generated = False
    if 'sim_turn_count' not in st.session_state:
        st.session_state.sim_turn_count = 0
    if 'sim_max_turns' not in st.session_state:
        st.session_state.sim_max_turns = 10
    if 'sim_completed' not in st.session_state:
        st.session_state.sim_completed = False
    if 'sim_awaiting_user_response' not in st.session_state:
        st.session_state.sim_awaiting_user_response = False
    if 'sim_current_user_message' not in st.session_state:
        st.session_state.sim_current_user_message = None

def reset_simulator():
    """Resetuje symulator"""
    st.session_state.sim_scenario = None
    st.session_state.sim_difficulty = None
    st.session_state.sim_context = None
    st.session_state.sim_ai_persona = None
    st.session_state.sim_messages = []
    st.session_state.sim_started = False
    st.session_state.sim_context_generated = False
    st.session_state.sim_turn_count = 0
    st.session_state.sim_completed = False
    st.session_state.sim_awaiting_user_response = False
    st.session_state.sim_current_user_message = None

# ===============================================
# GENEROWANIE KONTEKSTU PRZEZ AI
# ===============================================

def generate_scenario_context(scenario_id: str, difficulty: str) -> Dict:
    """Generuje szczeg√≥≈Çowy kontekst scenariusza u≈ºywajƒÖc AI"""
    try:
        from utils.ai_exercises import AIExerciseEvaluator
        evaluator = AIExerciseEvaluator()
        
        scenario = SCENARIOS[scenario_id]
        diff_settings = DIFFICULTY_LEVELS[difficulty]
        
        prompt = f"""Jeste≈õ ekspertem w tworzeniu realistycznych scenariuszy rozm√≥w biznesowych do trening√≥w C-IQ.

SCENARIUSZ: {scenario['name']} - {scenario['description']}
POZIOM TRUDNO≈öCI: {diff_settings['name']} - {diff_settings['description']}

ROLE:
- U≈ºytkownik gra: {scenario['user_role']}
- AI gra: {scenario['ai_role']}

Wygeneruj szczeg√≥≈Çowy, realistyczny kontekst tej sytuacji. Uwzglƒôdnij:

1. **KONTEKST DLA U≈ªYTKOWNIKA** (2-3 zdania):
   - Konkretna sytuacja z nazwami, liczbami, faktami
   - Dlaczego ta rozmowa jest teraz?
   - Co u≈ºytkownik chce osiƒÖgnƒÖƒá?

2. **PERSONA AI** (2-3 zdania):
   - Kim dok≈Çadnie jest rozm√≥wca? (imiƒô, stanowisko, charakterystyka)
   - Jakie ma obawy/frustracje w tej sytuacji?
   - Jak powinien reagowaƒá na r√≥≈ºne poziomy C-IQ zgodnie z poziomem trudno≈õci

3. **POCZƒÑTKOWA SYTUACJA** (1 zdanie):
   - Jak rozpoczyna siƒô rozmowa?
   - Kto zaczyna i w jakich okoliczno≈õciach?

Odpowiedz TYLKO w formacie JSON (bez ```json):
{{
    "user_context": "Szczeg√≥≈Çowy kontekst dla u≈ºytkownika...",
    "ai_persona": "Szczeg√≥≈Çowa persona AI rozm√≥wcy...",
    "situation_start": "Jak rozpoczyna siƒô rozmowa...",
    "ai_name": "Imiƒô AI rozm√≥wcy",
    "key_challenge": "G≈Ç√≥wne wyzwanie w tej rozmowie"
}}"""

        if hasattr(evaluator, 'gemini_model'):
            response = evaluator.gemini_model.generate_content(prompt)
            if response and response.text:
                content = response.text.strip()
                
                # Usu≈Ñ markdown
                if content.startswith("```json"):
                    content = content.replace("```json", "").replace("```", "").strip()
                elif content.startswith("```"):
                    content = content.replace("```", "").strip()
                
                # WydobƒÖd≈∫ JSON
                json_match = re.search(r'\{.*\}', content, re.DOTALL)
                if json_match:
                    return json.loads(json_match.group())
    
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Nie uda≈Ço siƒô wygenerowaƒá kontekstu AI: {str(e)}")
    
    # Fallback - prosty kontekst
    scenario = SCENARIOS.get(scenario_id, {})
    diff_settings = DIFFICULTY_LEVELS.get(difficulty, DIFFICULTY_LEVELS['medium'])
    
    import datetime
    current_date = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    
    return {
        "user_context": f"Jeste≈õ {scenario.get('user_role', 'uczestnik')} w sytuacji: {scenario.get('description', 'rozmowa biznesowa')}",
        "ai_persona": f"Rozm√≥wca to {scenario.get('ai_role', 'rozm√≥wca')} z poziomem trudno≈õci {diff_settings['name']}",
        "situation_start": "Rozmowa rozpoczyna siƒô teraz",
        "ai_name": "Rozm√≥wca",
        "key_challenge": f"Przekonanie {scenario.get('ai_role', 'rozm√≥wcy')} do wsp√≥≈Çpracy",
        "date": current_date
    }

# ===============================================
# ANALIZA C-IQ
# ===============================================

def analyze_message_ciq(message: str, scenario: Dict, context: Dict, turn_number: int = 1) -> Dict:
    """Analizuje poziom C-IQ wypowiedzi z uwzglƒôdnieniem kontekstowej adekwatno≈õci"""
    try:
        from utils.ai_exercises import AIExerciseEvaluator
        evaluator = AIExerciseEvaluator()
        
        # Okre≈õl fazƒô rozmowy
        if turn_number <= 2:
            phase = "opening"
        elif turn_number >= 8:
            phase = "closing"
        else:
            phase = "middle"
        
        optimal_levels = scenario.get('optimal_ciq', {}).get(phase, [3])
        context_notes = scenario.get('context_notes', '')
        
        prompt = f"""Jeste≈õ ekspertem w Conversational Intelligence. Oce≈Ñ wypowied≈∫ w kontek≈õcie rozmowy biznesowej.

KONTEKST: {context['user_context']}
ROLA U≈ªYTKOWNIKA: {scenario['user_role']}
WYZWANIE: {context['key_challenge']}
FAZA ROZMOWY: {phase} (runda {turn_number}/10)

WA≈ªNE - KONTEKSTOWA ADEKWATNO≈öƒÜ C-IQ:
{context_notes}

Optymalne poziomy C-IQ w tej fazie: {', '.join(['I (Transakcyjny)' if x==1 else 'II (Pozycyjny)' if x==2 else 'III (Transformacyjny)' for x in optimal_levels])}

WYPOWIED≈π: "{message}"

Oce≈Ñ poziom C-IQ (1-3):
- I (Transakcyjny): rozkazy, "ty musisz", konkretne dzia≈Çania, szybka reakcja
- II (Pozycyjny): argumenty, "ja vs ty", obrona pozycji, wyja≈õnienia
- III (Transformacyjny): "my", empatia, pytania otwarte, wsp√≥≈Çtworzenie

KLUCZOWE: Oce≈Ñ czy u≈ºyty poziom by≈Ç ADEKWATNY do sytuacji i fazy rozmowy.
Czasem C-IQ I lub II to OPTYMALNA decyzja (np. pilna sprawa, ustalanie granic, konkretne liczby).

Odpowied≈∫ JSON (bez ```json):
{{
    "level": "Transakcyjny/Pozycyjny/Transformacyjny",
    "level_number": 1/2/3,
    "score": 1-10,
    "reasoning": "Dlaczego ten poziom? (2-3 zdania)",
    "tip": "Konkretna wskaz√≥wka jak ulepszyƒá (1 zdanie)",
    "contextual_fit": "optimal/good/suboptimal",
    "contextual_comment": "Dlaczego ten poziom by≈Ç/nie by≈Ç adekwatny w tym kontek≈õcie? (1-2 zdania)"
}}"""

        if hasattr(evaluator, 'gemini_model'):
            response = evaluator.gemini_model.generate_content(prompt)
            if response and response.text:
                content = response.text.strip()
                if content.startswith("```json"):
                    content = content.replace("```json", "").replace("```", "").strip()
                elif content.startswith("```"):
                    content = content.replace("```", "").strip()
                
                json_match = re.search(r'\{.*\}', content, re.DOTALL)
                if json_match:
                    result = json.loads(json_match.group())
                    
                    level_num = result.get("level_number", 2)
                    contextual_fit = result.get("contextual_fit", "good")
                    
                    # Okre≈õl kolor bazujƒÖc na kontekstowej adekwatno≈õci
                    if contextual_fit == "optimal":
                        if level_num == 3:
                            color = "green"  # üü¢ Transformacyjny optymalny
                        else:
                            color = "blue"   # üîµ Transakcyjny/Pozycyjny optymalny w kontek≈õcie!
                    elif contextual_fit == "good":
                        color = "orange"  # üü° Akceptowalny
                    else:
                        color = "red"  # üî¥ Nieadekwatny do sytuacji
                    
                    result["color"] = color
                    result["optimal_levels"] = optimal_levels
                    result["phase"] = phase
                    return result
    
    except Exception as e:
        st.warning(f"‚ö†Ô∏è B≈ÇƒÖd analizy C-IQ: {str(e)}")
    
    # Fallback
    return {
        "level": "Pozycyjny",
        "level_number": 2,
        "score": 5,
        "reasoning": "Standardowa odpowied≈∫ biznesowa",
        "tip": "Spr√≥buj u≈ºyƒá pyta≈Ñ otwartych i jƒôzyka 'my razem'",
        "color": "orange",
        "contextual_fit": "good",
        "contextual_comment": "Poziom akceptowalny w tej sytuacji",
        "optimal_levels": [3],
        "phase": "middle"
    }

# ===============================================
# GENEROWANIE ODPOWIEDZI AI
# ===============================================

def generate_ai_response(scenario: Dict, context: Dict, difficulty: str, messages: List[Dict], user_ciq_level: str) -> str:
    """Generuje odpowied≈∫ AI rozm√≥wcy"""
    try:
        from utils.ai_exercises import AIExerciseEvaluator
        evaluator = AIExerciseEvaluator()
        
        recent_messages = messages[-6:] if len(messages) > 6 else messages
        conversation_history = "\n".join([
            f"{'AI (' + context.get('ai_name', scenario['ai_role']) + ')' if m['role'] == 'ai' else 'U≈ºytkownik'}: {m['content']}"
            for m in recent_messages
        ])
        
        diff_behavior = DIFFICULTY_LEVELS[difficulty]['ai_behavior']
        
        prompt = f"""Jeste≈õ ekspertem w symulacji realistycznych rozm√≥w biznesowych.

TWOJA ROLA: {scenario['ai_role']} (imiƒô: {context.get('ai_name', 'Rozm√≥wca')})
TWOJA PERSONA: {context['ai_persona']}
POZIOM TRUDNO≈öCI: {DIFFICULTY_LEVELS[difficulty]['name']}
JAK MASZ SIƒò ZACHOWYWAƒÜ: {diff_behavior}

KONTEKST SYTUACJI: {context['user_context']}
G≈Å√ìWNE WYZWANIE: {context['key_challenge']}

HISTORIA ROZMOWY:
{conversation_history}

POZIOM C-IQ U≈ªYTKOWNIKA W OSTATNIEJ WYPOWIEDZI: {user_ciq_level}

ZASADY ODPOWIEDZI:
1. Reaguj na poziom C-IQ u≈ºytkownika:
   - Transformacyjny ‚Üí bƒÖd≈∫ bardziej otwarty, obni≈º defensywno≈õƒá
   - Pozycyjny ‚Üí bƒÖd≈∫ umiarkowanie defensywny
   - Transakcyjny ‚Üí bƒÖd≈∫ bardzo defensywny, zamkniƒôty

2. Zachowaj poziom trudno≈õci ({DIFFICULTY_LEVELS[difficulty]['name']}):
   {diff_behavior}

3. Odpowiedz naturalnie, 2-4 zdania, jako {context.get('ai_name', scenario['ai_role'])}
4. NIE dodawaj meta-komentarzy

Odpowied≈∫:"""

        if hasattr(evaluator, 'gemini_model'):
            response = evaluator.gemini_model.generate_content(prompt)
            if response and response.text:
                return response.text.strip()
    
    except Exception as e:
        st.warning(f"‚ö†Ô∏è B≈ÇƒÖd generowania odpowiedzi: {str(e)}")
    
    # Fallback
    if user_ciq_level == "Transformacyjny":
        return f"Dziƒôkujƒô za zrozumienie. Faktycznie, to jest dobry punkt. Jak mo≈ºemy to wsp√≥lnie rozwiƒÖzaƒá?"
    elif user_ciq_level == "Pozycyjny":
        return f"Rozumiem Tw√≥j punkt widzenia, ale widzƒô to nieco inaczej. Mo≈ºe porozmawiajmy dalej?"
    else:
        return f"Okej, rozumiem. Co jeszcze?"

def generate_initial_ai_message(scenario: Dict, context: Dict) -> str:
    """Generuje poczƒÖtkowƒÖ wiadomo≈õƒá AI"""
    try:
        from utils.ai_exercises import AIExerciseEvaluator
        evaluator = AIExerciseEvaluator()
        
        prompt = f"""ROLA: {scenario['ai_role']} ({context.get('ai_name')})
PERSONA: {context['ai_persona']}
SYTUACJA: {context['situation_start']}

Rozpocznij rozmowƒô jako {context.get('ai_name')}. 2-3 zdania, naturalnie, wyra≈∫ problem/frustracjƒô zgodnie z kontekstem.

Odpowied≈∫:"""

        if hasattr(evaluator, 'gemini_model'):
            response = evaluator.gemini_model.generate_content(prompt)
            if response and response.text:
                return response.text.strip()
    
    except Exception:
        pass
    
    return f"Dzie≈Ñ dobry. Musimy porozmawiaƒá o wa≈ºnej sprawie."

# ===============================================
# G≈Å√ìWNY INTERFEJS
# ===============================================

def show_business_simulator():
    """G≈Ç√≥wny interfejs symulatora v2.0"""
    init_simulator_state()
    
    st.markdown("### üíº Symulator Rozm√≥w Biznesowych")
    st.markdown("Interaktywne symulacje z AI-generowanym kontekstem i mo≈ºliwo≈õciƒÖ poprawiania odpowiedzi")
    st.markdown("---")
    
    # ===== KROK 1: WYB√ìR SCENARIUSZA I TRUDNO≈öCI =====
    if not st.session_state.sim_context_generated:
        st.markdown("#### üéØ Krok 1: Wybierz scenariusz i poziom trudno≈õci")
        
        # Wyb√≥r scenariusza
        scenario_options = {s['name']: sid for sid, s in SCENARIOS.items()}
        selected_name = st.selectbox(
            "üìã Scenariusz:",
            options=list(scenario_options.keys()),
            key="sim_scenario_select"
        )
        selected_id = scenario_options[selected_name]
        scenario = SCENARIOS[selected_id]
        
        st.info(f"**{scenario['description']}**")
        
        col1, col2 = st.columns(2)
        with col1:
            st.markdown(f"üë§ **Ty:** {scenario['user_role']}")
        with col2:
            st.markdown(f"ü§ñ **AI:** {scenario['ai_role']}")
        
        st.markdown("---")
        
        # Wyb√≥r poziomu trudno≈õci
        st.markdown("**‚öôÔ∏è Poziom trudno≈õci:**")
        
        diff_cols = st.columns(3)
        
        for idx, (diff_id, diff_info) in enumerate(DIFFICULTY_LEVELS.items()):
            with diff_cols[idx]:
                if st.button(
                    diff_info['name'],
                    help=diff_info['description'],
                    width="stretch",
                    type="primary" if idx == 1 else "secondary"
                ):
                    st.session_state.sim_difficulty = diff_id
                    st.rerun()
        
        # Wy≈õwietl wybrany poziom
        if st.session_state.sim_difficulty:
            selected_diff = DIFFICULTY_LEVELS[st.session_state.sim_difficulty]
            st.success(f"‚úÖ Wybrany poziom: **{selected_diff['name']}**")
            st.caption(selected_diff['description'])
            
            st.markdown("---")
            st.markdown("#### üé¨ Krok 2: Wygeneruj szczeg√≥≈Çowy kontekst")
            
            if st.button("ü§ñ Generuj kontekst scenariusza przez AI", type="primary", width="stretch"):
                with st.spinner("üîÑ AI tworzy realistyczny kontekst sytuacji..."):
                    context = generate_scenario_context(selected_id, st.session_state.sim_difficulty)
                    
                    st.session_state.sim_scenario = selected_id
                    st.session_state.sim_context = context
                    st.session_state.sim_context_generated = True
                    st.rerun()
        
        return
    
    # ===== KROK 3: POKA≈ª WYGENEROWANY KONTEKST =====
    if not st.session_state.sim_started:
        scenario = SCENARIOS[st.session_state.sim_scenario]
        context = st.session_state.sim_context
        diff = DIFFICULTY_LEVELS[st.session_state.sim_difficulty]
        
        st.success(f"‚úÖ Kontekst wygenerowany!")
        
        col1, col2 = st.columns([2, 1])
        with col1:
            st.markdown(f"#### {scenario['name']}")
        with col2:
            st.metric("Poziom", diff['name'])
        
        st.markdown("---")
        
        # Wy≈õwietl szczeg√≥≈Çy
        st.markdown("**üìã Tw√≥j kontekst:**")
        st.info(context['user_context'])
        
        st.markdown(f"**ü§ñ Rozm√≥wca: {context.get('ai_name', scenario['ai_role'])}**")
        with st.expander("üé≠ Persona rozm√≥wcy", expanded=False):
            st.markdown(context['ai_persona'])
        
        st.markdown(f"**üé¨ PoczƒÖtek rozmowy:**")
        st.caption(context['situation_start'])
        
        st.markdown(f"**üéØ G≈Ç√≥wne wyzwanie:**")
        st.warning(context['key_challenge'])
        
        st.markdown("---")
        
        # Przyciski
        col1, col2 = st.columns(2)
        with col1:
            if st.button("‚ñ∂Ô∏è Rozpocznij symulacjƒô", type="primary", width="stretch"):
                st.session_state.sim_started = True
                st.session_state.sim_messages = []
                st.session_state.sim_awaiting_user_response = True  # Zawsze czekamy na u≈ºytkownika
                
                # Je≈õli AI rozpoczyna - dodaj pierwszƒÖ wiadomo≈õƒá
                if scenario['initiator'] == 'ai':
                    initial_msg = generate_initial_ai_message(scenario, context)
                    st.session_state.sim_messages.append({
                        'role': 'ai',
                        'content': initial_msg
                    })
                
                # XP za start
                try:
                    from data.users import award_xp_for_activity
                    award_xp_for_activity(
                        st.session_state.username,
                        'tool_used',
                        1,
                        {'tool_name': 'Business Simulator v2', 'scenario': st.session_state.sim_scenario}
                    )
                except:
                    pass
                
                st.rerun()
        
        with col2:
            if st.button("üîÑ Wygeneruj inny kontekst", width="stretch"):
                st.session_state.sim_context_generated = False
                st.session_state.sim_context = None
                st.rerun()
        
        return
    
    # ===== AKTYWNA SYMULACJA =====
    scenario = SCENARIOS[st.session_state.sim_scenario]
    context = st.session_state.sim_context
    diff = DIFFICULTY_LEVELS[st.session_state.sim_difficulty]
    
    # Sprawd≈∫ czy zako≈Ñczono
    if st.session_state.sim_completed:
        show_summary(scenario, context, diff)
        return
    
    # Nag≈Ç√≥wek
    col1, col2, col3 = st.columns([2, 1, 1])
    with col1:
        st.markdown(f"#### {scenario['name']}")
        st.caption(f"Rozm√≥wca: {context.get('ai_name', scenario['ai_role'])}")
    with col2:
        st.metric("Poziom", diff['name'])
    with col3:
        turns = st.session_state.sim_turn_count
        max_turns = st.session_state.sim_max_turns
        st.metric("Runda", f"{turns}/{max_turns}")
    
    # Przycisk zako≈Ñcz
    if st.button("üèÅ Zako≈Ñcz rozmowƒô", help="Zako≈Ñcz i zobacz podsumowanie"):
        st.session_state.sim_completed = True
        st.rerun()
    
    st.markdown("---")
    
    # Panel kontekstu - zawsze widoczny
    st.markdown("### üìã Kontekst sytuacji")
    
    col_ctx1, col_ctx2 = st.columns([1, 1])
    
    with col_ctx1:
        st.markdown("**üìù Tw√≥j kontekst:**")
        st.info(context['user_context'])
        
        st.markdown(f"**üéØ G≈Ç√≥wne wyzwanie:**")
        st.warning(context['key_challenge'])
    
    with col_ctx2:
        st.markdown(f"**ü§ñ Rozm√≥wca: {context.get('ai_name', scenario['ai_role'])}**")
        st.info(context['ai_persona'])
        
        st.markdown(f"**üé¨ PoczƒÖtek rozmowy:**")
        st.caption(context['situation_start'])
    
    st.markdown("---")
    
    # Historia rozmowy
    user_message_count = 0  # Licznik wiadomo≈õci u≈ºytkownika
    
    for idx, msg in enumerate(st.session_state.sim_messages):
        if msg['role'] == 'ai':
            with st.chat_message("assistant", avatar="ü§ñ"):
                st.markdown(msg['content'])
        else:
            user_message_count += 1
            remaining = st.session_state.sim_max_turns - user_message_count + 1
            
            with st.chat_message("user", avatar="üë§"):
                # Nag≈Ç√≥wek z numerem rundy
                st.caption(f"üí¨ Runda {user_message_count}/{st.session_state.sim_max_turns} (pozosta≈Ço: {remaining})")
                st.markdown(msg['content'])
                
                # Analiza C-IQ
                if 'ciq_analysis' in msg:
                    analysis = msg['ciq_analysis']
                    color = analysis.get('color', 'blue')
                    contextual_fit = analysis.get('contextual_fit', 'good')
                    contextual_comment = analysis.get('contextual_comment', '')
                    
                    # Buduj feedback z uwzglƒôdnieniem kontekstowej adekwatno≈õci
                    feedback_text = f"""**üìä C-IQ: {analysis['level']}** (ocena: {analysis['score']}/10)

{analysis['reasoning']}"""
                    
                    # Dodaj komentarz o kontekstowej adekwatno≈õci dla C-IQ I i II gdy sƒÖ optymalne
                    if contextual_fit == "optimal" and analysis.get('level_number', 3) in [1, 2]:
                        feedback_text += f"\n\n‚ú® **≈öwietny wyb√≥r!** {contextual_comment}"
                    elif contextual_comment:
                        feedback_text += f"\n\nÔøΩ {contextual_comment}"
                    
                    feedback_text += f"\n\nÔøΩüí° **Wskaz√≥wka:** {analysis['tip']}"
                    
                    if color == 'green':
                        st.success(feedback_text)
                    elif color == 'blue':
                        st.info(feedback_text)  # Niebieskie t≈Ço dla optymalnego C-IQ I/II
                    elif color == 'orange':
                        st.warning(feedback_text)
                    else:
                        st.error(feedback_text)
                    
                    # Przyciski POWT√ìRZ / DALEJ / ZAKO≈ÉCZ (tylko dla ostatniej wiadomo≈õci u≈ºytkownika)
                    if idx == len(st.session_state.sim_messages) - 1 and not st.session_state.sim_awaiting_user_response:
                        # Wy≈õrodkuj przyciski u≈ºywajƒÖc pustych kolumn po bokach
                        col_space1, col_btn1, col_btn2, col_btn3, col_space2 = st.columns([1, 2, 2, 2, 1])
                        
                        with col_btn1:
                            if st.button("üîÑ Powt√≥rz", key=f"retry_{idx}", width="stretch", help="Usu≈Ñ swojƒÖ odpowied≈∫ i spr√≥buj ponownie"):
                                # Usu≈Ñ ostatniƒÖ wiadomo≈õƒá u≈ºytkownika
                                st.session_state.sim_messages.pop()
                                # Ustaw flagƒô aby pokazaƒá pole czatu
                                st.session_state.sim_awaiting_user_response = True
                                st.rerun()
                        
                        with col_btn2:
                            if st.button("‚úÖ Dalej", key=f"continue_{idx}", type="primary", width="stretch", help="Kontynuuj rozmowƒô"):
                                # Generuj odpowied≈∫ AI
                                with st.spinner(f"üí≠ {context.get('ai_name')} my≈õli..."):
                                    user_ciq = analysis.get('level', 'nieznany')
                                    ai_response = generate_ai_response(
                                        scenario, 
                                        context, 
                                        st.session_state.sim_difficulty,
                                        st.session_state.sim_messages,
                                        user_ciq
                                    )
                                    
                                    st.session_state.sim_messages.append({
                                        'role': 'ai',
                                        'content': ai_response
                                    })
                                    
                                    st.session_state.sim_turn_count += 1
                                    st.session_state.sim_awaiting_user_response = True
                                    st.rerun()
                        
                        with col_btn3:
                            if st.button("üèÅ Zako≈Ñcz", key=f"finish_{idx}", width="stretch", help="Zako≈Ñcz rozmowƒô i zobacz podsumowanie"):
                                st.session_state.sim_completed = True
                                st.rerun()
    
    # Input u≈ºytkownika - pokazuj tylko gdy czekamy na odpowied≈∫
    if st.session_state.sim_turn_count < st.session_state.sim_max_turns:
        if st.session_state.sim_awaiting_user_response:
            user_input = st.chat_input("Twoja odpowied≈∫...")
            
            if user_input and user_input.strip():
                # Dodaj wiadomo≈õƒá u≈ºytkownika
                st.session_state.sim_messages.append({
                    'role': 'user',
                    'content': user_input
                })
                
                # Analizuj C-IQ z numerem rundy
                with st.spinner("üîç Analizujƒô poziom C-IQ..."):
                    turn_number = st.session_state.sim_turn_count
                    ciq_analysis = analyze_message_ciq(user_input, scenario, context, turn_number)
                    st.session_state.sim_messages[-1]['ciq_analysis'] = ciq_analysis
                
                st.session_state.sim_awaiting_user_response = False
                st.rerun()
    else:
        st.info("üèÅ OsiƒÖgnƒÖ≈Çe≈õ maksymalnƒÖ liczbƒô rund. Kliknij 'Zako≈Ñcz rozmowƒô' aby zobaczyƒá podsumowanie.")

# ===============================================
# PODSUMOWANIE
# ===============================================

def generate_ai_feedback(scenario: Dict, context: Dict, diff: Dict, messages: List[Dict]) -> Dict:
    """Generuje szczeg√≥≈Çowy feedback AI na podstawie ca≈Çej rozmowy z uwzglƒôdnieniem kontekstowej adekwatno≈õci C-IQ"""
    try:
        from utils.ai_exercises import AIExerciseEvaluator
        evaluator = AIExerciseEvaluator()
        
        # Przygotuj transkrypcjƒô
        conversation = []
        for msg in messages:
            role_name = context.get('ai_name', scenario['ai_role']) if msg['role'] == 'ai' else scenario['user_role']
            conversation.append(f"{role_name}: {msg['content']}")
        
        transcript = "\n\n".join(conversation)
        
        # Zbierz analizy C-IQ z informacjƒÖ o kontekstowej adekwatno≈õci
        user_messages = [m for m in messages if m['role'] == 'user']
        ciq_summary = []
        contextual_wins = []  # Przypadki gdy C-IQ I/II by≈Ç optymalny
        
        for idx, msg in enumerate(user_messages, 1):
            if 'ciq_analysis' in msg:
                analysis = msg['ciq_analysis']
                level = analysis.get('level', 'Nieznany')
                level_num = analysis.get('level_number', 0)
                contextual_fit = analysis.get('contextual_fit', 'good')
                
                ciq_summary.append(f"- Runda {idx}: {level} (adekwatno≈õƒá: {contextual_fit})")
                
                # Zaznacz optymalne u≈ºycie C-IQ I/II
                if contextual_fit == "optimal" and level_num in [1, 2]:
                    contextual_wins.append(f"Runda {idx}: {analysis.get('contextual_comment', '')}")
        
        ciq_text = "\n".join(ciq_summary) if ciq_summary else "Brak analizy"
        contextual_wins_text = "\n".join(contextual_wins) if contextual_wins else "Brak"
        
        prompt = f"""Jeste≈õ ekspertem w Conversational Intelligence i coachingu komunikacji biznesowej.

Przeanalizuj poni≈ºszƒÖ symulowanƒÖ rozmowƒô biznesowƒÖ i przygotuj konstruktywny feedback.

WA≈ªNE - KONTEKSTOWA ADEKWATNO≈öƒÜ C-IQ:
{scenario.get('context_notes', 'Poziom transformacyjny jest zazwyczaj optymalny, ale nie zawsze.')}

Pamiƒôtaj: C-IQ I (Transakcyjny) i II (Pozycyjny) mogƒÖ byƒá OPTYMALNYM wyborem w okre≈õlonych sytuacjach!
- C-IQ I: pilne sprawy, konkretne dzia≈Çania, szybka reakcja
- C-IQ II: ustalanie granic, obrona standard√≥w, jasna argumentacja
- C-IQ III: budowanie relacji, rozw√≥j, wsp√≥≈Çtworzenie

KONTEKST:
- Scenariusz: {scenario['name']}
- Rola u≈ºytkownika: {scenario['user_role']}
- Rozm√≥wca: {context.get('ai_name', scenario['ai_role'])}
- Poziom trudno≈õci: {diff['name']}
- Wyzwanie: {context['key_challenge']}

TRANSKRYPCJA ROZMOWY:
{transcript}

POZIOMY C-IQ U≈ªYTKOWNIKA:
{ciq_text}

PRZYPADKI OPTYMALNEGO U≈ªYCIA C-IQ I/II (do pochwa≈Çy!):
{contextual_wins_text}

Przygotuj feedback w formacie JSON (bez ```json):
{{
    "strengths": [
        "Mocna strona 1 (konkretny przyk≈Çad z rozmowy - doceniaj tak≈ºe dobre u≈ºycie C-IQ I/II!)",
        "Mocna strona 2 (konkretny przyk≈Çad z rozmowy)",
        "Mocna strona 3 (konkretny przyk≈Çad z rozmowy)"
    ],
    "areas_to_improve": [
        "Obszar do rozwoju 1 (co dok≈Çadnie poprawiƒá - ale NIE krytykuj C-IQ I/II je≈õli by≈Ç adekwatny!)",
        "Obszar do rozwoju 2 (co dok≈Çadnie poprawiƒá)",
        "Obszar do rozwoju 3 (co dok≈Çadnie poprawiƒá)"
    ],
    "key_tip": "Jedna najwa≈ºniejsza wskaz√≥wka do zastosowania w nastƒôpnej rozmowie (1-2 zdania)",
    "overall_rating": 1-10,
    "summary": "Kr√≥tkie podsumowanie rozmowy (2-3 zdania)"
}}"""

        if hasattr(evaluator, 'gemini_model'):
            response = evaluator.gemini_model.generate_content(prompt)
            if response and response.text:
                content = response.text.strip()
                
                if content.startswith("```json"):
                    content = content.replace("```json", "").replace("```", "").strip()
                elif content.startswith("```"):
                    content = content.replace("```", "").strip()
                
                import json
                json_match = re.search(r'\{.*\}', content, re.DOTALL)
                if json_match:
                    return json.loads(json_match.group())
    
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Nie uda≈Ço siƒô wygenerowaƒá feedback AI: {str(e)}")
    
    # Fallback
    return {
        "strengths": [
            "Uko≈Ñczy≈Çe≈õ symulacjƒô rozmowy",
            "ƒÜwiczy≈Çe≈õ umiejƒôtno≈õci komunikacyjne",
            "Pr√≥bowa≈Çe≈õ r√≥≈ºnych podej≈õƒá"
        ],
        "areas_to_improve": [
            "Spr√≥buj u≈ºywaƒá wiƒôcej pyta≈Ñ otwartych",
            "Stosuj jƒôzyk 'my' zamiast 'ty'",
            "Praktykuj empatyczne s≈Çuchanie"
        ],
        "key_tip": "W nastƒôpnej rozmowie zacznij od pytania otwartego, aby lepiej zrozumieƒá perspektywƒô rozm√≥wcy.",
        "overall_rating": 6,
        "summary": "Dobra pr√≥ba komunikacji. Z kolejnymi ƒáwiczeniami bƒôdziesz coraz lepszy!"
    }

def generate_transcript(scenario: Dict, context: Dict, messages: List[Dict]) -> str:
    """Generuje transkrypcjƒô rozmowy w formacie tekstowym"""
    lines = []
    lines.append("=" * 60)
    lines.append("TRANSKRYPCJA ROZMOWY - SYMULATOR BIZNESOWY")
    lines.append("=" * 60)
    lines.append("")
    lines.append(f"Scenariusz: {scenario['name']}")
    lines.append(f"Twoja rola: {scenario['user_role']}")
    lines.append(f"Rozm√≥wca: {context.get('ai_name', scenario['ai_role'])}")
    lines.append(f"Data: {context.get('date', 'N/A')}")
    lines.append("")
    lines.append("=" * 60)
    lines.append("")
    
    for idx, msg in enumerate(messages, 1):
        if msg['role'] == 'ai':
            role_name = context.get('ai_name', scenario['ai_role'])
            lines.append(f"[{role_name}]:")
        else:
            role_name = scenario['user_role']
            lines.append(f"[{role_name}]:")
            
        lines.append(msg['content'])
        
        # Dodaj szczeg√≥≈ÇowƒÖ analizƒô C-IQ dla wiadomo≈õci u≈ºytkownika
        if msg['role'] == 'user' and 'ciq_analysis' in msg:
            analysis = msg['ciq_analysis']
            level = analysis.get('level', 'N/A')
            score = analysis.get('score', 0)
            contextual_fit = analysis.get('contextual_fit', 'unknown')
            
            # Symbol adekwatno≈õci
            fit_symbol = "‚úÖ" if contextual_fit == "optimal" else "üëç" if contextual_fit == "good" else "‚ö†Ô∏è"
            fit_text = {
                "optimal": "OPTYMALNY",
                "good": "Dobry",
                "suboptimal": "Do poprawy"
            }.get(contextual_fit, "N/A")
            
            lines.append(f"  ‚Üí C-IQ: {level} ({score}/10) | Adekwatno≈õƒá: {fit_symbol} {fit_text}")
            
            # Dodaj komentarz kontekstowy je≈õli istnieje
            if 'contextual_comment' in analysis and analysis['contextual_comment']:
                lines.append(f"  üí° {analysis['contextual_comment']}")
        
        lines.append("")
    
    lines.append("=" * 60)
    lines.append("KONIEC TRANSKRYPCJI")
    lines.append("=" * 60)
    
    return "\n".join(lines)

def show_summary(scenario: Dict, context: Dict, diff: Dict):
    """Wy≈õwietla podsumowanie symulacji"""
    st.success("‚úÖ Rozmowa zako≈Ñczona!")
    st.markdown("### üìä Podsumowanie")
    
    total_turns = st.session_state.sim_turn_count
    
    # Podstawowe statystyki
    col_stat1, col_stat2 = st.columns(2)
    with col_stat1:
        st.metric("üí¨ Liczba rund", total_turns)
        st.metric("‚öôÔ∏è Poziom trudno≈õci", diff['name'])
    with col_stat2:
        st.metric("üìù Scenariusz", scenario['name'])
        st.metric("ü§ñ Rozm√≥wca", context.get('ai_name', scenario['ai_role']))
    
    st.markdown("---")
    
    # Analiza poziom√≥w C-IQ z kontekstowƒÖ adekwatno≈õciƒÖ
    user_messages = [m for m in st.session_state.sim_messages if m['role'] == 'user']
    if user_messages:
        ciq_levels = [m.get('ciq_analysis', {}).get('level', 'Nieznany') for m in user_messages if 'ciq_analysis' in m]
        
        if ciq_levels:
            from collections import Counter
            level_counts = Counter(ciq_levels)
            
            # Policz kontekstowƒÖ adekwatno≈õƒá
            optimal_count = sum(1 for m in user_messages if m.get('ciq_analysis', {}).get('contextual_fit') == 'optimal')
            good_count = sum(1 for m in user_messages if m.get('ciq_analysis', {}).get('contextual_fit') == 'good')
            suboptimal_count = sum(1 for m in user_messages if m.get('ciq_analysis', {}).get('contextual_fit') == 'suboptimal')
            
            # Policz optymalne u≈ºycie C-IQ I/II
            optimal_low_ciq = sum(1 for m in user_messages 
                                 if m.get('ciq_analysis', {}).get('contextual_fit') == 'optimal' 
                                 and m.get('ciq_analysis', {}).get('level_number', 3) in [1, 2])
            
            st.markdown("#### üìä Twoje poziomy C-IQ:")
            
            col_ciq1, col_ciq2, col_ciq3 = st.columns(3)
            
            transformacyjny = level_counts.get("Transformacyjny", 0)
            pozycyjny = level_counts.get("Pozycyjny", 0)
            transakcyjny = level_counts.get("Transakcyjny", 0)
            total = len(ciq_levels)
            
            with col_ciq1:
                st.metric(
                    "üü¢ Transformacyjny",
                    f"{transformacyjny} ({(transformacyjny/total*100):.0f}%)",
                    delta="Doskona≈Çy poziom" if transformacyjny > pozycyjny + transakcyjny else None
                )
            
            with col_ciq2:
                st.metric(
                    "üü° Pozycyjny",
                    f"{pozycyjny} ({(pozycyjny/total*100):.0f}%)",
                    delta=None
                )
            
            with col_ciq3:
                st.metric(
                    "ÔøΩ Transakcyjny",
                    f"{transakcyjny} ({(transakcyjny/total*100):.0f}%)",
                    delta=None
                )
            
            # Poka≈º adekwatno≈õƒá kontekstowƒÖ
            st.markdown("#### üéØ Adekwatno≈õƒá do kontekstu:")
            
            col_fit1, col_fit2, col_fit3 = st.columns(3)
            
            with col_fit1:
                st.metric(
                    "‚úÖ Optymalne",
                    f"{optimal_count} ({(optimal_count/total*100):.0f}%)",
                    delta="≈öwietnie!" if optimal_count > total/2 else None
                )
            
            with col_fit2:
                st.metric(
                    "üëç Dobre",
                    f"{good_count} ({(good_count/total*100):.0f}%)",
                    delta=None
                )
            
            with col_fit3:
                st.metric(
                    "‚ö†Ô∏è Do poprawy",
                    f"{suboptimal_count} ({(suboptimal_count/total*100):.0f}%)",
                    delta="Uwaga!" if suboptimal_count > 0 else None,
                    delta_color="inverse"
                )
            
            # Pochwa≈Ça za elastyczno≈õƒá sytuacyjnƒÖ
            if optimal_low_ciq > 0:
                st.info(f"""üîµ **≈öwietna elastyczno≈õƒá sytuacyjna!** 
                
U≈ºy≈Çe≈õ C-IQ I (Transakcyjny) lub II (Pozycyjny) w spos√≥b optymalny {optimal_low_ciq} {'raz' if optimal_low_ciq == 1 else 'razy'}. 
To pokazuje, ≈ºe rozumiesz kiedy ni≈ºsze poziomy C-IQ sƒÖ w≈Ça≈õciwym wyborem!""")
            
            # Og√≥lna ocena
            dominant = level_counts.most_common(1)[0][0]
            adaptability_score = (optimal_count / total * 100) if total > 0 else 0
            
            if adaptability_score >= 70:
                st.success(f"üéâ **Wysoka adaptacyjno≈õƒá ({adaptability_score:.0f}%)** - Doskonale dopasujesz poziom C-IQ do kontekstu!")
            elif adaptability_score >= 50:
                st.info(f"üí° **Dobra adaptacyjno≈õƒá ({adaptability_score:.0f}%)** - Dobrze dopasujesz C-IQ, ale jest przestrze≈Ñ na rozw√≥j.")
            else:
                st.warning(f"‚ö†Ô∏è **Adaptacyjno≈õƒá do rozwiniƒôcia ({adaptability_score:.0f}%)** - Zwracaj wiƒôkszƒÖ uwagƒô na kontekst sytuacyjny.")
    
    st.markdown("---")
    
    # Generuj feedback AI
    with st.spinner("ü§ñ AI przygotowuje szczeg√≥≈Çowy feedback..."):
        feedback = generate_ai_feedback(scenario, context, diff, st.session_state.sim_messages)
    
    # Wy≈õwietl feedback AI
    st.markdown("### üéØ Szczeg√≥≈Çowy feedback")
    
    # Og√≥lna ocena
    rating = feedback.get('overall_rating', 5)
    st.markdown(f"**Og√≥lna ocena:** {'‚≠ê' * rating} ({rating}/10)")
    
    if 'summary' in feedback:
        st.info(feedback['summary'])
    
    col_feed1, col_feed2 = st.columns(2)
    
    with col_feed1:
        st.markdown("#### üí™ Mocne strony:")
        for strength in feedback.get('strengths', []):
            st.success(f"‚úÖ {strength}")
    
    with col_feed2:
        st.markdown("#### üìà Obszary do rozwoju:")
        for area in feedback.get('areas_to_improve', []):
            st.warning(f"üî∏ {area}")
    
    # Kluczowa wskaz√≥wka
    if 'key_tip' in feedback:
        st.markdown("### üí° Kluczowa wskaz√≥wka na przysz≈Ço≈õƒá:")
        st.success(f"**{feedback['key_tip']}**")
    
    st.markdown("---")
    
    # Transkrypcja
    st.markdown("### üìÑ Transkrypcja rozmowy")
    
    transcript_text = generate_transcript(scenario, context, st.session_state.sim_messages)
    
    with st.expander("üìú Zobacz pe≈ÇnƒÖ transkrypcjƒô", expanded=False):
        st.text(transcript_text)
    
    # Przycisk pobierania
    import datetime
    filename = f"transkrypcja_{scenario.get('name', 'rozmowa').replace(' ', '_')}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    
    st.download_button(
        label="üì• Pobierz transkrypcjƒô (TXT)",
        data=transcript_text,
        file_name=filename,
        mime="text/plain",
        width="stretch"
    )
    
    st.markdown("---")
    try:
        from data.users import award_xp_for_activity
        award_xp_for_activity(
            st.session_state.username,
            'ai_exercise',
            15,
            {
                'exercise_name': 'Business Simulator v2',
                'scenario': st.session_state.sim_scenario,
                'difficulty': st.session_state.sim_difficulty,
                'turns': total_turns
            }
        )
        st.success("üéâ **+15 XP** za uko≈Ñczenie!")
    except:
        pass
    
    # Przyciski
    st.markdown("---")
    col1, col2 = st.columns(2)
    with col1:
        if st.button("üéØ Nowa symulacja", type="primary", width="stretch"):
            reset_simulator()
            st.rerun()
    with col2:
        if st.button("‚ùå Zamknij", width="stretch"):
            reset_simulator()
            if 'active_simulator' in st.session_state:
                st.session_state.active_simulator = None
            st.rerun()
